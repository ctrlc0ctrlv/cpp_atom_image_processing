#ifndef CPD_H
#define CPD_H

#include <core/geometry.h>
#include <eigen3/Eigen/Dense>

/**
 * @brief Coherent point drift algorithm.
 *
 * Rigid point set registration that uses EM-algorithm.
 *
 * @see https://arxiv.org/pdf/0905.2635.pdf
 */
class alignas(EIGEN_MAX_ALIGN_BYTES) CPD
{
public:
	/**
	 * @brief Dimension of points.
	 */
	static constexpr int D = 2;

	/**
	 * @brief Noise weight parameter.
	 * Must be in the range [0;1).
	 */
	float w = 0.5;

	/**
	 * @brief Number of M-steps without scaling change.
	 */
	int maxItersNoScaling = 100;

	/**
	 * @brief Number of M-steps with scaling change.
	 */
	int maxItersWithScaling = 100;

	/**
	 * @brief Performs EM-algorithm to find affine transformation.
	 *
	 * @param[in] X [NxD] - the first point set (data points generated by GMM).
	 * Usually `X` acts as a target set.
	 * @param[in] Y [MxD] - the second point set (GMM centroids). Usually `Y`
	 * acts as a source set.
	 * @param[out] Rs [DxD] - rotation matrix (with scale).
	 * @param[out] t [Dx1] - translation vector.
	 *
	 * X-like aligned matrix or vector can be obtained then as follows:
	 * ```
	 * X = Y * transform.matrix().transpose();
	 * Eigen::Vector2f x = transform * Y.row(i).transpose();
	 * ```
	 * @note It is assumed that dimension `D = 2`.
	 * @throw `std::invalid_argument` if either `X` or `Y` are empty.
	 */
	void operator ()(const Eigen::MatrixX2f &X, const Eigen::MatrixX2f &Y,
					 AffineTransform &transform);

	void getP(Eigen::MatrixXf &);

private:
	Eigen::MatrixX2f X;
	Eigen::Vector2f tx;
	float dispX;

	Eigen::MatrixX2f Y;
	Eigen::Vector2f ty;
	float dispY;

	float s;
	float sigmaSqr;
	int N;
	int M;
	Eigen::MatrixXf P;
	Eigen::Matrix2f R;
	Eigen::Vector2f t;

	/**
	 * @brief Initializes parameters and computes `sigmaSqr` value.
	 */
	void init(const Eigen::MatrixX2f &X, const Eigen::MatrixX2f &Y);

	/**
	 * @brief E-step (expectation).
	 *
	 * Computes probability of correspondence P [MxN].
	 */
	void Estep();

	/**
	 * @brief M-step (maximization).
	 *
	 * @param changeScaling - if true then `s` value will be changed during
	 * `Mstep()`.
	 *
	 * Optimizes scaling value `s` and translation vector `t` [Dx1].
	 */
	void Mstep(bool changeScaling);
};

#endif // CPD_H
